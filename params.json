{"name":"Canable","tagline":"Simple Ruby authorization system.","body":"# Canable\r\n\r\nSimple Ruby authorization system.\r\n\r\n## Install\r\n\r\n```\r\ngem install canable\r\n```\r\n\r\n## Cans\r\n\r\nWhatever class you want all permissions to run through should include Canable::Cans.\r\n\r\n```ruby\r\nclass User\r\n  include MongoMapper::Document\r\n  include Canable::Cans\r\nend\r\n```\r\n\r\nThis means that an instance of a user automatically gets can methods for the default REST actions: `can_view?(resource)`, `can_create?(resource)`, `can_update?(resource)`, `can_destroy?(resource)`.\r\n\r\n## Ables\r\n\r\nEach of the can methods simply calls the related \"able\" method (viewable, creatable, updatable, destroyable) for the action (view, create, update, delete). Canable comes with defaults for this methods that you can then override as makes sense for your permissions.\r\n\r\n```ruby\r\nclass Article\r\n  include MongoMapper::Document\r\n  include Canable::Ables\r\nend\r\n```\r\n\r\nIncluding Canable::Ables adds the able methods to the class including it. In this instance, article now has `viewable_by?(user)`, `creatable_by?(user)`, `updatable_by?(user)` and `destroyable_by?(user)`.\r\n\r\nLets say an article can be viewed and created by anyone, but only updated or destroyed by the user that created the article. To do that, you could leave `viewable_by?` and `creatable_by?` alone as they default to true and just override the other methods.\r\n\r\n```ruby\r\nclass Article\r\n  include MongoMapper::Document\r\n  include Canable::Ables\r\n  userstamps! # adds creator and updater\r\n\r\n  def updatable_by?(user)\r\n    creator == user\r\n  end\r\n\r\n  def destroyable_by?(user)\r\n    updatable_by?(user)\r\n  end\r\nend\r\n```\r\n\r\nLet's look at some sample code now:\r\n\r\n```ruby\r\njohn = User.create(:name => 'John')\r\nsteve = User.create(:name => 'Steve')\r\n\r\nruby = Article.new(:title => 'Ruby')\r\njohn.can_create?(ruby) # true\r\nsteve.can_create?(ruby) # true\r\n\r\nruby.creator = john\r\nruby.save\r\n\r\njohn.can_view?(ruby) # true\r\nsteve.can_view?(ruby) # true\r\n\r\njohn.can_update?(ruby) # true\r\nsteve.can_update?(ruby) # false\r\n\r\njohn.can_destroy?(ruby) # true\r\nsteve.can_destroy?(ruby) # false\r\n```\r\n\r\nNow we can implement our permissions for each resource and then always check whether a user can or cannot do something. This makes it all really easy to test. In one common pattern, a single permission flag controls whether or not users can perform multiple administrator-specific operations. Canable can honor that flag with:\r\n\r\n```ruby\r\ndef writable_by?(user)\r\n  user.can_do_anything?\r\nend\r\nalias_method :creatable_by?, :writable_by?\r\nalias_method :updatable_by?, :writable_by?\r\nalias_method :destroyable_by?, :writable_by?\r\n```\r\n\r\nNext, how would you use this in the controller. \r\n\r\n## Enforcers\r\n\r\n```ruby\r\nclass ApplicationController\r\n  include Canable::Enforcers\r\nend\r\n```\r\n\r\nIncluding `Canable::Enforcers` adds an enforce permission method for each of the actions defined (by default view/create/update/destroy). It is the same thing as doing this for each Canable action:\r\n\r\n```ruby\r\nclass ApplicationController\r\n  include Canable::Enforcers\r\n\r\n  delegate :can_view?, :to => :current_user\r\n  helper_method :can_view? # so you can use it in your views\r\n  hide_action :can_view?\r\n\r\n  private\r\n    def enforce_view_permission(resource)\r\n      raise Canable::Transgression unless can_view?(resource)\r\n    end\r\nend\r\n```\r\n\r\nWhich means you can use it like this:\r\n\r\n```ruby\r\nclass ArticlesController < ApplicationController\r\n  def show\r\n    @article = Article.find!(params[:id])\r\n    enforce_view_permission(@article)\r\n  end\r\nend\r\n```\r\n\r\nIf the user `can_view?` the article, all is well. If not, a `Canable::Transgression` is raised which you can decide how to handle (show 404, slap them on the wrist, etc.). For example:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  rescue_from Canable::Transgression, :with => :render_403\r\n\r\n  protected\r\n  def render_403(e)\r\n    # notify normal exception handler(s) here\r\n    render :status => 403\r\n  end\r\n```\r\n\r\n## Adding Your Own Actions\r\n\r\nYou can add your own actions like this:\r\n\r\n```ruby\r\nCanable.add(:publish, :publishable)\r\n```\r\n\r\nThe first parameter is the can method (ie: `can_publish?`) and the second is the able method (ie: `publishable_by?`).\r\n\r\nAbles can also be added as class methods. For example, to restrict access to an index action:\r\n\r\n```ruby\r\nCanable.add(:index, :indexable)\r\n```\r\n\r\nThen enforce by passing the class instead of the instance:\r\n\r\n```ruby\r\nclass ArticlesController < ApplicationController\r\n  def index\r\n    @articles = Article.all\r\n    enforce_index_permission(Article)\r\n  end\r\nend\r\n```\r\n\r\nThen in the article model, add the able check as a class method:\r\n\r\n```ruby\r\nclass Article\r\n  # ...\r\n  def self.indexable_by?(user)\r\n    !user.nil?\r\n  end\r\nend\r\n```\r\n\r\n## Review\r\n\r\nSo, lets review: cans go on user model, ables go on everything, you override ables in each model where you want to enforce permissions, and enforcers go after each time you find or initialize an object in a controller. Bing, bang, boom.\r\n\r\n## Contributing\r\n\r\n* Fork the project.\r\n* Make your feature addition or bug fix.\r\n* Add tests for it. This is important so I don't break it in a\r\n  future version unintentionally.\r\n* Commit, do not mess with rakefile, version, or history.\r\n  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)\r\n* Send me a pull request. Bonus points for topic branches.\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2010 John Nunemaker. See LICENSE for details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}